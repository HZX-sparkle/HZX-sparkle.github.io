[{"title":"Markdown学习日记","url":"/2022/11/08/My-First-Post/","content":"Markdown\nMarkdown是一种轻量级标记语言，排版语法简洁，让人们更多地关注内容本身而非排版。它使用易读易写的纯文本格式编写文档，可与HTML混编，可导出 HTML、PDF 以及本身的 .md 格式的文件。因简洁、高效、易读、易写，Markdown被大量使用，如Github、Wikipedia、简书等。\n\nMarkdown基础语法\n标题语法要创建标题，可在句子或单词前加“#”号，“#”号的多少代表标题的等级。\n\n如#### 四级标题将显示成\n四级标题\ntips最好在#和标题之间加一个空格，以方便兼容\n段落语法要创建段落，请使用空白行将一行或多行文本进行分隔。tips不要用空格（spaces）或制表符（ tabs）缩进段落。\n\n\n\n✅ Do this\n❌ Don’t do this\n\n\n\nDon&#39;t put tabs or spaces in front of your paragraphs.\n  This can result in unexpected formatting problems. Don&#39;t add tabs or spaces in front of paragraphs.\n\n\n换行语法在一行的末尾添加两个或多个空格，然后按回车键,即可创建一个换行(&lt;br&gt;)tips几乎每个 Markdown 应用程序都支持两个或多个空格进行换行，称为 结尾空格（trailing whitespace) 的方式，但这是有争议的，因为很难在编辑器中直接看到空格，并且很多人在每个句子后面都会有意或无意地添加两个空格。由于这个原因，你可能要使用除结尾空格以外的其它方式来换行。幸运的是，几乎每个 Markdown 应用程序都支持另一种换行方式：HTML 的 &lt;br&gt; 标签。为了兼容性，请在行尾添加“结尾空格”或 HTML 的 &lt;br&gt; 标签来实现换行。还有两种其他方式我并不推荐使用。CommonMark 和其它几种轻量级标记语言支持在行尾添加反斜杠 (\\) 的方式实现换行，但是并非所有 Markdown 应用程序都支持此种方式，因此从兼容性的角度来看，不推荐使用。并且至少有两种轻量级标记语言支持无须在行尾添加任何内容，只须键入回车键（return）即可实现换行。\n强调语法要强调时，可用粗体或斜体两种方式，也可同时加粗加斜，**粗体**渲染成粗体*斜体*渲染成斜体***粗加斜***渲染成粗加斜tips虽然还有其他的方式进行强调，但为了兼容考虑，最好使用加*号的方法\n引用语法要创建块引用，请在段落前添加一个 &gt; 符号。\n&gt; Dorothy followed her through many of the beautiful rooms in her castle.\n渲染效果如下所示：\n\nDorothy followed her through many of the beautiful rooms in her castle.\n\n多个段落的块引用块引用可以包含多个段落。为段落之间的空白行添加一个 &gt; 符号。\n&gt; Dorothy followed her through many of the beautiful rooms in her castle.&gt;&gt; The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.\n渲染效果如下：\n\nDorothy followed her through many of the beautiful rooms in her castle.\nThe Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.\n\n嵌套块引用块引用可以嵌套。在要嵌套的段落前添加一个 &gt;&gt; 符号。\n&gt; Dorothy followed her through many of the beautiful rooms in her castle.&gt;&gt;&gt; The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.\n渲染效果如下：\n\nDorothy followed her through many of the beautiful rooms in her castle.\n\nThe Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.\n\n\n带有其它元素的块引用块引用可以包含其他 Markdown 格式的元素。并非所有元素都可以使用，你需要进行实验以查看哪些元素有效。\n&gt; #### The quarterly results look great!&gt;&gt; - Revenue was off the chart.&gt; - Profits were higher than ever.&gt;&gt;  *Everything* is going according to **plan**.\n渲染效果如下：\n\nThe quarterly results look great!\nRevenue was off the chart.\nProfits were higher than ever.\n\nEverything is going according to plan.\n\n列表语法将多个条目组织成有序或无序列表\n有序列表创建有序列表，只需在数字后面加上英文句点即可，数字也无需按顺序排列，只需以1起始，如\n1.2.3.\n\n将显示成\n\n第一项\n\n第二项\n\n第三项\n\n\n无序列表创建一个无序列表，只需在每个列表项前加- ,*或+即可，如\n- one- two- three\n\n将显示成\n\none\ntwo\nthree\n\n嵌套列表在列表中，除了文字，我们还能插入其他的东西，只需在其之前添加四个空格键或者一个tab键即可。如文字\n1. first thing2. second thing\tthe other thing3. third thing\n\n将表示成\n\nfirst thing\nsecond thing the other thing\nthird thing\n\n引用块\n1. first thing2. second thing\t&gt;the other thing3. third thing\n\n将表示成\n\nfirst thing\nsecond thing\nthe other thing\n\n\nthird thing\n\n代码块（通常需要添加8个空格或2个tab键）\n1.  Open the file.2.  Find the following code block on line 21:        &lt;html&gt;          &lt;head&gt;            &lt;title&gt;Test&lt;/title&gt;          &lt;/head&gt;3.  Update the title to match the name of your website.\n\n将表示成\n\n Open the file.\n\nFind the following code block on line 21:\n &lt;html&gt;\n   &lt;head&gt;\n     &lt;title&gt;Test&lt;/title&gt;\n   &lt;/head&gt;\n\n\n Update the title to match the name of your website.\n\n\n代码语法如果想将单词或语段显示成代码，可将其包含在反引号（`）中。如\n`word`\n\n将表示成word\n转义反引号如果想让代码中出现反引号，可以将这段代码用双反引号包裹。如\n``这是一个带`的代码``\n\n将表示成这是一个带`的代码\n代码块如果想创建一个代码块，可以将代码的每一行至少缩进四个空格或一个tab键如\ninclude &lt;stdio.h&gt;int main()&#123;printf(&quot;Hello World!&quot;);return 0;&#125;\n\n将表示成    include &lt;stdio.h&gt;    int main()    {    printf(“Hello World!”);    return 0;    }\n这种方法除了在列表中使用之外可能有些麻烦，所以我们还可以将代码块包裹在三个反引号或者三个波浪号之间来创建代码块。如\n~~~代码~~~\n\n将表示成\n代码\n\n\n\n分割线语法要添加一条分割线，只需使用三个星号（***）、破折号（---）或者下划线（___）即可，渲染结果如下，\n\ntips\n为了兼容性，我们需要在分割线上下添加空白行。\n链接语法要添加链接，链接文本放在中括号内，链接地址放在后面的括号中，链接title可选。超链接Markdown语法代码：[超链接显示名](超链接地址 &quot;超链接title&quot;)，如\n这是一个链接 [Markdown语法](https://markdown.com.cn)。\n\n渲染效果如下：这是一个链接 Markdown语法。\n给链接增加title链接title是鼠标悬停在链接上时将出现的文字，要增加这样的效果，我们只需在链接后用引号添加链接title，同时用空格将两者分隔。如\n链接 [Markdown语法](https://markdown.com.cn &quot;come on, try out!&quot;)。\n\n将渲染成：链接 Markdown语法。\n网址和email地址将url和email地址用尖括号包裹即可将其变为链接。如\n&lt;https://hzx-sparkle.github.io/&gt;&lt;2841287903@qq.com&gt;\n\n将渲染成https://hzx-sparkle.github.io/&#x32;&#x38;&#52;&#x31;&#50;&#56;&#55;&#x39;&#x30;&#x33;&#x40;&#x71;&#113;&#46;&#x63;&#x6f;&#x6d;\n带格式化的链接使链接带上强调，加斜，代码块等效果，与正常文本没有什么区别，只是需要注意一点，即变成代码块时，需要在方括号里加反引号。\nI love supporting the **[EFF](https://eff.org)**.This is the *[Markdown Guide](https://www.markdownguide.org)*.See the section on [`code`](#code).\n\n将渲染成I love supporting the EFF.This is the Markdown Guide.See the section on code.\ntips为了更好的兼容，尽量用%20代替空格。\n\n\n\n✅ Do this\n❌ Don’t do this\n\n\n\n[link](https://www.example.com/my%20great%20page)\n[link](https://www.example.com/my great page)\n\n\n图片语法要添加图像，请使用感叹号 (!), 然后在方括号增加替代文本，图片链接放在圆括号里，括号里的链接后可以增加一个可选的图片标题文本。插入图片Markdown语法代码：![图片alt](图片链接 &quot;图片title&quot;)。\n![avatar](https://cdn.staticaly.com/gh/HZX-sparkle/image-hosting@master/20221108/avatar.46usqyain9s0.webp &quot;avatar&quot;)\n\n渲染效果如下，\n\n图片链接给图片增加链接，可将图像的Markdown 括在方括号中，然后将链接添加在圆括号中。\n[![这是图片](E:\\20220\\Pictures\\Saved Pictures\\logo1.png &quot;logo&quot;)](https://hzx-sparkle.github.io/)\n\n渲染效果如下，![这是图片](E:\\20220\\Pictures\\Saved Pictures\\logo1.png “logo”)\n转义字符语法要显示原本用于格式化 Markdown 文档的字符，请在字符前面添加反斜杠字符 \\ 。\n\\* Without the backslash, this would be a bullet in an unordered list.\n\n渲染效果如下：\n* Without the backslash, this would be a bullet in an unordered list.\n可做转义的字符以下列出的字符都可以通过使用反斜杠字符从而达到转义目的。\n\n\n\nCharacter\nName\n\n\n\n\\\nbackslash\n\n\n`\nbacktick (see also escaping backticks in code)\n\n\n*\nasterisk\n\n\n_\nunderscore\n\n\n{ }\ncurly braces\n\n\n[ ]\nbrackets\n\n\n( )\nparentheses\n\n\n#\npound sign\n\n\n+\nplus sign\n\n\n-\nminus sign (hyphen)\n\n\n.\ndot\n\n\n!\nexclamation mark\n\n\n|\npipe (see also escaping pipe in tables)\n\n\n","tags":["markdown"]},{"title":"Clion的常用快捷键","url":"/2022/12/24/Clion%E7%9A%84%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/","content":"1.CLion编辑快捷键Ctrl+Spacebar 基本代码完成(任何类、方法或变量的名称)\nCtrl+Shift+Spacebar 智能代码完成(按预期类型筛选方法和变量列表)\nCtrl+Shift+Enter 完整的语句\nCtrl+P 参数信息(在方法调用参数内)\nCtrl+Q 快速查找文档\nCtrl+Mouse over code 简短的信息\nCtrl+F1 在插入符号处显示错误或警告的说明\nAlt+Insert 生成代码…(Getters, Setters, Constructors, hashCode/equals, toString)\nCtrl+O 覆盖方法\nCtrl+I 实现方法\nCtrl+Alt+T 围绕与…(如果. .其他,试试. .catch, for, synchronized等)\nCtrl+/ 注释/取消注释行注释\nCtrl+Shift+/ 注释/取消注释块注释\nCtrl+W 选择连续递增代码块\nCtrl+Shift+W 减少当前选择到以前的状态\nAlt+Q 显示强度动作和快速修复\nCtrl+Alt+L 重新格式化代码\nCtrl+Alt+O 优化进口\nCtrl+Alt+I 自动缩进线(年代)\nTab/Shift+Tab 缩进/ unindent选定的行\nCtrl+X 剪切当前行或选定块到剪贴板\nCtrl+C 复制当前行或选定块到剪贴板\nCtrl+V 从剪贴板粘贴\nCtrl+Shift+V 从最近的缓冲区粘贴…\nCtrl+D 复制当前行或选定块\nCtrl+Y 删除插入符号处的行\nCtrl+Shift+J 智能线连接\nCtrl+Enter 智能线分裂\nShift+Enter 开始新的一行\nCtrl+Shift+U 在插入符号或选定块上切换大小写\nCtrl+Shift+]/[ 选择直到代码块结束/开始\nCtrl+Delete 删除到字尾\nCtrl+Backspace 删除到单词开始\nCtrl+ NumPad +/- 展开/折叠代码块\nCtrl+Alt+ NumPad +/- 展开所有/折叠所有\nCtrl+F4 关闭活动编辑器选项卡\nAlt+Shift+Click 将插入符号放置在多个位置\nEsc 恢复单插入字符模式\nAlt+G/Alt+Shift+G 添加/删除下次出现的当前单词选择\n2.CLion查找和替换Double Shift 到处寻找\nCtrl+F 找到\nF3 / Shift+F3 查找下一个/找到之前\nCtrl+R 取代\nCtrl+Shift+F 找到的路径\nCtrl+Shift+R 在路径替换\n3.CLion编译、运行快捷键Ctrl+F9 建设项目\nAlt+Shift+F10 选择配置并运行\nAlt+Shift+F9 选择配置和调试\nShift+F10 运行\nShift+F9 调试\n4.CLion Debug快捷键F8 步进\nF7 进入\nShift+F8 步出\nAlt+F9 运行到光标\nAlt+F8 计算表达式\nF9 恢复程序\nCtrl+F8 Toggle breakpoint\nCtrl+Shift+F8 查看断点\n5.CLion Live模板快捷键Ctrl+Alt+J 使用Live模板包围\nCtrl+J 插入Live模板\nfor (索引;,)循环\niter 迭代范围(C + + 11)\nitit 使用Begin/End成员函数迭代\nincboost 在CMake中包含使用Boost的指示\nfunction 在CMake中创建新的函数定义器\n6.CLion搜索文件、导航快捷键Ctrl+N 搜索类文件\nCtrl+Shift+N 搜索文件\nCtrl+Alt+Shift+N 定位到符号\nAlt+Right Arrow/Left Arrow 转到下一个/上一个编辑器选项卡\nF12 返回到前一个工具窗口\nEsc 转到编辑器(从工具窗口)\nShift+Esc 隐藏活动的或最近活动的窗口\nCtrl+Shift+F4 关闭活动运行/信息/发现/…选项卡\nCtrl+G 去行\nCtrl+E 最近文件弹出\nCtrl+Alt+Left Arrow/Right Arrow 向后/向前导航\nCtrl+Shift+Backspace 导航到最后一次编辑位置\nAlt+F1 在任意视图中选择当前文件或符号\nCtrl+B 定位声明\nCtrl+Alt+B 搜索实现类(年代)\nCtrl+Alt+Home 转到相关符号(头/源)\nCtrl+Shift+I 文件)\nCtrl+Shift+B 开放快速定义查找\nCtrl+U 进入类型声明\nAlt+Up Arrow/Down Arrow 父类方法/超类\nCtrl+]/[ 转到前一个/下一个方法\nCtrl+F12 移动到代码块结束/移动到代码开始\nCtrl+H 弹出文件结构\nCtrl+Alt+H 类型层次结构\nF2/Shift+F2 调用层次结构\nF11 下一个/以前的错误突出显示\nCtrl+F11 切换书签\nCtrl+0…9 用助记符切换书签\nShift+F11 转到编号书签\n7.CLion常用快捷键Alt+0…9 打开相应的工具窗口\nAlt+Shift+I 用当前配置文件检查当前文件\nCtrl+` 快速开关电流方案\nCtrl+Alt+S 编辑应用程序设置\nCtrl+Shift+F12 隐藏所有工具窗口\nAlt+Shift+F 添加到收藏夹\n8.CLion 使用过的搜索Alt+F7 发现使用\nCtrl+F7 在文件中查找用法\nCtrl+Shift+F7 突出显示文件中的用法\nCtrl+Alt+F7 显示用法\n9.VCS/Git快捷键Ctrl+K 向VCS/Git提交项目\nCtrl+T 从VCS更新项目\nAlt+Shift+C 查看最近的变化\nAlt+` VCS/Git快速弹出\n10.CLion重构快捷键Ctrl+Alt+Shift+T 重构\nF5 复制\nF6 移动\nAlt+Delete 安全的删除\nShift+F6 重命名\nCtrl+F6 更改签名\nCtrl+Alt+M 提取功能\nCtrl+Alt+N 内联\nCtrl+Alt+P 引入参数\nCtrl+Alt+V 引入变量\nCtrl+Alt+C 介绍常数\nCtrl+Alt+D 介绍定义\n","tags":["Clion","C语言"]},{"title":"Hello World","url":"/2022/11/07/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"matu22级C语言期中考试","url":"/2022/11/25/matu22%E7%BA%A7C%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E8%80%83%E8%AF%95/","content":"c-1-prime求指定范围之内的素数问题描述：输入2个空格分隔的整数m和n，求这个2个数之间的所有素数并输出。要求输出不包含m和n，且输出数据用空格分隔(包括最后1个数据输出后也要输出空格）。任何不合法是输入输出”error”。\n#include &lt;stdio.h&gt;#include &lt;math.h&gt;int isPrime(int n)&#123;\tif(n&lt;=1) return 0;\t\tif(n==2||n==3)&#123;\t\treturn 1;\t&#125;\t\t\tif(n%6!=1&amp;&amp;n%6!=5)&#123;\t\treturn 0;\t&#125;\t\tint s=(int)sqrt(1.0*n);\tfor (int i=5;i&lt;=s;i=i+6)&#123;\t\tif(n%i==0||n%(i+2)==0)&#123;\t\t\treturn 0;\t\t&#125;\t&#125;\t\treturn 1;&#125;int main()&#123;\tint m,n;\tint input=scanf(&quot;%d %d&quot;,&amp;m,&amp;n); //判断输入是否正确（这里太苟了）\tif(m&lt;=1&amp;&amp;n&lt;=1||m==n||input!=2)&#123;\t\tprintf(&quot;error&quot;);\t\treturn 0;\t&#125;\t\tint max,min;\tif(m&lt;n)&#123;\t\tmax=n;\t\tmin=m;\t&#125;else&#123;\t\tmax=m;\t\tmin=n;\t&#125;\t\tfor(int i=min+1;i&lt;max;i++)&#123;\t\tif(isPrime(i)==1)&#123;\t\t\tprintf(&quot;%d &quot;,i);\t\t&#125;\t&#125;\t\treturn 0;&#125;\n字符串逆序输出输入一个字符串，要求按相反的顺序输出各个字符。例如，输入为AbcD，则输出为DcbA。提示：这个题与习题4.1类似，但需注意的是：存储要输入的字符串的字符数组的长度要足够大；如果输入字符串过长，对应存储的字符数组是否会越界。可以考虑实现变长数组。\n输入输出格式要求：    输入格式：string回车    输出格式：gnirts例如：输入：hello回车输出：olleh\n#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123;\tchar a[100];\tchar b[100];\tgets(a);\tint l=strlen(a);\tfor(int i=0;i&lt;l;i++)&#123;\t\tb[i]=a[l-i-1];\t&#125;\tputs(b);&#125;\n\na-4-删除star问题描述：现在有一串字符串（长度不超过100），规定输入的字符串中只包含字母和*号。如果包含其他符号，则输出”error\\n”请编写程序，实现以下功能：除了字符串前后的*号之外，将串中的其他*号全部删除。输出字符串之后要输出回车再结束程序。如果输入不符合要求，则输出”error”和回车。假如输入的字符串是****A*BC*DEF*G********,删除串中的*号之后，字符串变成****ABCDEFG********\n#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123;\tchar a[100];\tgets(a);\tchar b[100];\tint l=strlen(a);\tint j=0;\tint k;\tint begin=0;\tint end=l-1;\tfor(int i=0;i&lt;l;i++)&#123;\t\tif(a[i]!=&#x27;*&#x27;&amp;&amp;a[i]&lt;&#x27;A&#x27;&amp;&amp;a[i]&gt;&#x27;z&#x27;)&#123;\t\t\tprintf(&quot;error\\n&quot;);\t\t\treturn 0;\t\t&#125;\t\tif(a[i]==&#x27;*&#x27;&amp;&amp;j==0) printf(&quot;*&quot;);\t\tif(a[i]!=&#x27;*&#x27;)&#123;\t\t\tif(j==0) begin=i;\t\t\tb[j]=a[i];\t\t\tj++;\t\t&#125;\t&#125;\t\tfor(int i=0;i&lt;j;i++)&#123;\t\tprintf(&quot;%c&quot;,b[i]);\t&#125;\tfor( ;a[end]==&#x27;*&#x27;;end--)&#123;\t\tprintf(&quot;%c&quot;,a[end]);\t&#125;\tprintf(&quot;\\n&quot;);&#125;\n","categories":["码图"],"tags":["C语言"]},{"title":"基础算法（一）排序","url":"/2023/01/18/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%E6%8E%92%E5%BA%8F/","content":"快速排序快速排序（quick sort）是一种比较常用而且比较基础的排序算法，第一次知道这个算法还是当我查询c++的sort函数是如何实现的时候知道的，其实，c++的sort就是一种优化之后的快排。\n基本思想快速排序的基本思想其实就是分治（divide and conquer），具体的实现逻辑可分为三步：\n\n先从数组中确定一个数作为分界点，这个分界点的取法没有限制，我们一般取第一个数，最后一个数或中间的数均可。\n调整区间，在确定分界点x后，数组被分成两个区间，我们在这一步要做的就是把数组中所有小于等于x的数放到左区间，所有大于等于x的数放到右区间。\n递归处理左右两段，处理完左右两段后，两个区间已经有了基本的有序性，接下来我们只需对两段继续进行上述操作，直至个区间只有一个数，这样整个数组就是有序的了。\n\n实现方法在了解快排的基本思想后，我们可以知道，第一步和第三步都是比较简单的，重要的是如何优美地实现第二步，对此，这里介绍两种实现方法。\n第一种，我们在原来数组Q的基础上，再创建两个额外的数组A和B，之后遍历数组Q，把所有小于等于x的数放到A中，所有大于x的数放到B中，遍历完之后，再把A和B写入Q中。这样的方法是很容易想到的，但有一个很明显的缺点，那就是创建数组需要内存空间，加上递归，需要的空间会很大，这样暴力的做法显然不能成为最优解，于是，我们来看看第二种。\n第二种做法，我们不创建新的数组，而是用两个指针a和b分别指向数组的最左端和最右端，然后让指针a开始向右移动，如果a指向的数是小于等于分界点x的，那么a++，直到a指向的数大于x，a停止移动，接着移动b，同理，如果b指向的数大于等于x的，那么b–，直到b指向的数小于等于x，b停止，然后我们交换a和b所指向的数，并继续上述操作，直到两指针相遇。通过这种方法，我们能够不占用任何额外空间，同时快速的完成区间的调整。\n代码模板#include &lt;iostream&gt;using namespace std;void quick_sort(int q[], int l, int r)&#123;\tif (l &gt;= r) return;\tint x = q[l + r &gt;&gt; 1], i = l - 1, j = r + 1; //选取分界点x， 并定义i和j\twhile (i &lt; j)\t&#123;\t\twhile (q[++i] &lt; x); //移动i直至q[i]&gt;=x\t\twhile (q[--j] &gt; x); //移动j直至q[j]&lt;=x\t\tif (i &lt; j)\t\t&#123;\t//交换两个数\t\t\tint temp = q[i];\t\t\tq[i] = q[j];\t\t\tq[j] = temp;\t\t&#125;\t&#125;\t//递归处理左右两段\tquick_sort(q, l, j);\tquick_sort(q, j + 1, r);&#125;\n\n\n\n归并排序归并排序（merge sort）也是一种比较常见的排序方法，这里可以说是把递归运用到了极致，一开始我还有点晕，之后看了关于归并操作的图解之后就清晰多了。\n基本思想这里归并排序也是采用了分治的策略，具体实现方法如下：\n\n选取分界点，和快排一样，我们需要选择一个分界点，但是，我们这里一般是选择中间点。\n递归排序，这一部分是比较难理解的，这样说，如果要完成后面的归并，我们合并的这两个区间首先必须得是有序的，但是我们选取完分界点后，显然两个区间不会是完全有序的，这样我们就需要进行递归，一直递归到几乎每个区间都只剩一个数，这样我们能说每个区间都是有序的，然后再来进行下面的操作。\n归并——合二为一，在递归操作后，我们能保证要合并的两个区间是有序的，接下来我们需要做的就是把那两个区间里的数合并起来，是两个区间合并成一个有序的大区间。\n\n实现方法第二步比较难理解，但是不难实现，这里我们重点介绍第三步，也就是归并的实现方法。像上面快排一样，我们可以用两个指针a和b，分别指向两个区间的起点，然后新建一个数组arr存放两个区间合并之后的结果，我们比较a和b指向的数，较小的一个数存入arr中，指向较小的数的指针向前移动一格，这样重复操作，直至有一个指针走到了末尾，接下来由于两个区间都是有序的，我们可以直接将另一个指针指向的区间剩余部分直接存入arr中，这样两个有序区间就能合并成一个更大的有序区间。\n代码模板#include &lt;iostream&gt;void merge_sort(int q[], int l, int r)&#123;\tif (l &gt;= r) return;\tint mid = l + r &gt;&gt; 1;    //递归至底端\tmerge_sort(q, l, mid);\tmerge_sort(q, mid + 1, r);\tint k = 0, i = l, j = mid + 1;    //对两区间中的数进行比较并合并\twhile (i &lt;= mid &amp;&amp; j &lt;= r)\t&#123;\t\tif (q[i] &lt; q[j]) temp[k++] = q[i++];\t\telse temp[k++] = q[j++];\t&#125;    //如果一段走到末尾，则将另一段剩下所有数存入temp\twhile (i &lt;= mid) temp[k++] = q[i++];\twhile (j &lt;= r) temp[k++] = q[j++];\tfor (int i = l, j = 0; i &lt;= r; ++i, ++j)\t&#123;\t\tq[i] = temp[j];\t&#125;&#125;\n\n\n\n","categories":["基础算法"],"tags":["算法","快速排序","归并排序"]},{"title":"基础算法（二）二分","url":"/2023/01/19/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BA%8C%E5%88%86/","content":"整数二分二分查找这个概念很多人应该都知道，但许多初学者经常遇到的一个误区就是，他们觉得只有当一个数组有序的时候才能用二分，其实这是不对的。\n基本思想二分分的是某个性质，只要这个数组满足能够一分为二，左边满足这个性质，右边不满足这个性质，那么我们就可以通过二分查找到这个性质的边界，这才是二分的本质，我们可以找边界上满足这个性质的，也可以找边界上不满足这个性质的，由此我们有两种情况，下面分别来说。\n实现方法第一种情况，对一个数组Q，左右两端记为l和r，当我们要找边界上满足这个性质的数的时候，我们先有中间数mid，之后我们判断q[mid]是否满足这个性质，如果满足，则将区间缩小至[ mid , r ]，否则将区间缩小至[ l , mid-1 ]，这样重复下去，直至区间中只剩一个数，这个数就是我们要找的边界上满足这个性质的数。\n第二种情况，当我们要找边界上不满足这个性质的数时，一样地，我们判断q[mid]是否满足这个性质，如果满足，则将区间缩小至[mid+1 , r]，否则将区间缩小至[ l , mid ]。\n在刚刚接触这个的时候，很多人都觉得这个有点抽象，不好理解，不知道这个区间为什么是这样变的，我说说我的理解，首先最重要的一点，我们需要保证区间内我们要找的点是始终存在的，拿第一种情况举例，我们要找的点是满足这个性质的，所以当mid也满足这个性质时，我们可以说mid应该包含在之后的区间里，因为在极端情况下，mid完全有可能就是我们要找的这个点，反之，当我们已经知道mid不满足这个性质，那我们就能说，我们要找的点肯定不是mid，这时我们划分区间时就应该把mid去掉，其次，我们应该尽量使区间端点有着不同的性质，因为我们找的是边界点，如果区间内所有的点都满足这个性质，那么还谈何边界呢？当我们清楚这两点后，接下来的代码实现就不难了。\n代码模板#include &lt;iostream&gt;using namespace std;//当区间划分为[mid+1 , r]和[l , mid]时int b_search1(int l, int r)&#123;\twhile (l &lt; r)\t&#123;\t\tint mid = l + r &gt;&gt; 1;\t\tif (check(mid)) r = mid;\t\telse l = mid + 1;\t&#125;\treturn l;&#125;//当区间划分为[mid , r]和[l , mid-1]时int b_search2(int l, int r)&#123;\twhile (l &lt; r)\t&#123;\t\tint mid = l + r + 1 &gt;&gt; 1; //这里要注意当l=mid时要让mid = l + r + 1 &gt;&gt; 1\t\tif (check(mid)) l = mid;\t\telse r = mid - 1;\t&#125;\treturn l;&#125;\n\n\n\n浮点数二分和整数二分不同，浮点数二分我们不需要去考虑边界问题，这就使得浮点数二分的实现简单了许多。基本思想与整数二分一致，我们下面讲讲它的实现方法。\n实现方法由于是浮点数，我们每次二分时能严格地将区间一分为二，与整数二分一样的，我们每次选取区间时要满足两个条件，即保证区间内我们要找的点是始终存在的，同时尽量使区间端点有着不同的性质，而与整数二分不同的是它的结束条件，当两个区间端点的距离足够近时，我们就可以结束循环，将r或者l当作我们的答案。\n","categories":["基础算法"],"tags":["算法","整数二分","浮点数二分"]},{"title":"记一次项目课作业","url":"/2023/03/25/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%A1%B9%E7%9B%AE%E8%AF%BE%E4%BD%9C%E4%B8%9A/","content":"物联网安全实验2实验准备设置树莓派这里就是实验一的内容，大体上就是\n\n覆写sd卡，先安装PL-App Launcher，把sd卡接usb转换器插上电脑，然后打开PL-App Launcher设置device-name，device-password，wifi-ssid和wifi-password，这里我本来想用发的路由器搞，但是接上宽带之后发现有密码，而且还不好重置，所以就干脆直接用寝室的路由器了，那么就注意上面设置的wifi名称和密码应该都是寝室的wifi和密码，最后点击write disk image覆写sd卡。\n树莓派联网，把刚刚弄好的sd卡插回树莓派，用网线把树莓派和路由器连在一起，然后给树莓派插上电，这样再打开PL-App Launcher就能看到树莓派已经连上了，页面是这样的就行了点击connect，浏览器进入登陆页面，然后这里的password就是在第一步里设置的device-password，输入正确之后应该就能看到这样的页面\n\n安装kali虚拟机先把U盘里拷的文件复制到一个文件夹里，然后直接上官网Downloads – Oracle VM VirtualBox，下载windows系统下的VirtualBox，下完之后点击导入，选中刚刚复制到文件夹里的Kali_IoTSec.ova文件，导入完成之后打开，如果显示网卡有错误，则点击更改网络设置，或者在管理器页面点击设置-网络-连接方式，改为网络地址转换（NAT），点击ok，然后在再启动虚拟机，这时应该能正常打开，username是root，password是toor，之后就能成功进入虚拟机。(之后记得把网络设置改回桥接网络，不然电脑连不上网)\n第一部分 保护远程访问步骤一\n首先配置好树莓派，然后使用PL-App Launcher连接树莓派，随后如图点击，打开终端后输入ifconfig，便会显示树莓派的ip地址以及子网掩码，比如说我这里查到的树莓派的IP地址是192.168.101.10，子网掩码是255.255.255.0。（其实在PL-Apps Launcher里面，树莓派连上网之后的括号里面就是它的ip地址，这里只是为了确认一下它的子网掩码）\n\n配置kali虚拟机，为了能和树莓派连接，我们要让虚拟机和树莓派在同一网络地址下，我们先打开终端，输入ifconfig回车，如果虚拟机的网络地址和树莓派的一样，那我感觉可以不改虚拟机的IP地址，不过如果要改的话，我们也可以ifconfig eth0 198.168.101.xx来改ip地址，注意这里要让它的网络地址，就是前三段，和树莓派一致，最后一段一般取20到200之间就行，修改完成后，再输入ifconfig，这时显示的应该就是我们修改的ip了。\n\n在vm上确认树莓派的ip，虽然之前已经确认过了，但是这里还要我们确认，不过也很简单，在终端输入fping -ag 192.168.101.00/24回车（注意，这里只用输入网络地址，即前三段，最后一段输入0即可），接下来几排就会输出在同一网络地址下设备的ip，不过应该是因为我们用的是寝室的路由器，所以除了我们虚拟机和树莓派的ip地址，还会显示别的ip，无伤大雅。\n\n使用ssh进入树莓派，为了保险起见，我们先确保树莓派的ssh是开着的，使用PL-App Launcher，点击connect，由于有了之前实验准备的记忆，浏览器应该能直接进入树莓派的页面，接着我们按照第0步打开它的终端，依次输入systemctl enable ssh和systemctl start ssh，至此树莓派的ssh就能够打开了。然后我们回到虚拟机，在终端输入ssh pi@后面加树莓派的ip地址，然后按回车，不出意外应该会有一句Are you sure you want to continue connecting (yes/no)?，我们输入yes并回车，随后系统就会提示我们输入密码，然后我们就输入树莓派默认的密码raspberry（注意，Linux输入密码时是不会有显示的，怕自己输错了可以直接复制粘贴），登陆成功后会出现这样一个界面，前面的东西变成绿的了。\n\n\n这样，我们的步骤一就完成了！\n步骤二 保护用户账户这个步骤比较简单，直接看老师发的就行。最后重启再次登录pi账户时，输入默认密码raspberry应该还是可以登进去的，因为我们刚刚只是新建了一个用户edgerunners并对这个用户进行了设置，然而对原来的用户没有影响，这个默认的用户还是在的，所以我们还是能登进去，只是说登录edgerunners账户的时候要用刚刚设置的密码登录。\n步骤三 安全远程访问这一步也比较简单，按着步骤走就行，只有一个要注意的点就是那个用nano文本编辑器编辑 /etc/ssh/sshd_config 文件，要注意有一个下划线_不要看成空格了，然后那个预测应该也能看出来kevin会无法访问，kingbob能正常访问。\n第二部分 删除默认Pi账户在步骤a中文件显示为pi ALL=(ALL) NOPASSWD: ALL，能推断出我们现在创建的所有用户应该都是能直接访问超级用户权限且无需密码的，验证方法也很简单，登录每个用户的账户，用sudo开头打一句命令看能不能直接执行就行了。步骤c中问如何验证Pi账户是否被删除，我觉得就是尝试一下登录Pi账户，然后系统会说Permission denied, please try again.，这样应该就能说明Pi账户已经被删除了。\n第三部分 简单防火墙步骤一 确定正在 Pi 上侦听哪些网络服务启动 Telnet 和 vsftpd 服务时，遇见Failed to start openbsd-inetd.service: Unit openbsd-inetd.service not found.和Failed to start vsftpd.service: Unit vsftpd.service not found.报错，上网查了一下，好像是压根没下这俩东西，就直接搜了一下如何安装telnet 和vsftpd ，(21条消息) 树莓派上安装vsftpd:FTP服务器_断线纸鸢张的博客-CSDN博客，(21条消息) 树莓派远程连接的四种方式（最全）_sudo-wang的博客-CSDN博客，下载完之后再输入这两条命令就咩问题了。\n步骤二 检查ufw状态在b中输入sudo ufw status时显示没有ufw这个命令，应该又是没有安装的原因，输入sudo apt-get install ufw进行安装，安装完成后，一切显示正常。\n步骤五 降低ssh的威胁一切限制设置完成后，目前对ssh连接应该是采用了limit措施，限制 SSH 服务的登录尝试，而如果没有创建https规则，那么由于隐式拒绝规则，所有到达IoTPI接口的HTTP流量都会被丢弃。\n步骤六 用nmap扫描这一步里nmap扫描可能会用挺长时间，如果想看扫描进度可以按一下回车，会有一个“About 多少多少 Done”，那个就是进度。扫描完成后应该会是这样我把步骤一时候扫描的也放上来，对比一下。可以看到，之前是有65531 closed ports，就是说有65531个端口是直接关闭的，只剩四个端口分别对应ftp，ssh，telnet和http服务，而在这里变成了65534 filtered ports，有65534个端口被“过滤”了，这里显然是我们刚刚设置的防火墙起了作用，具体的关于nmap端口状态的介绍可以看一下这个博客，端口扫描基础 | Nmap参考指南(Man Page)对比两图可以看到，现在是只有一个端口是开放的，端口号我这里是22的tcp端口，而且是service是ssh，所以说设置了防火墙之后，kali上的pi无法再访问ftp，telnet和http协议。\n实验3这一次实验不需要用到树莓派，更多是在linux系统下操作。\n第一部分按照给的教程来，问题不大，步骤二里最后破解的密码应该是root:device:10933:0:99999:7:::\n步骤三将固件的文件系统解压后，显示出此文件的属性，可以看到是squashfs文件系统\n步骤四里，知道目标的文件系统很重要是因为\n\n文件系统类型决定了如何存储和访问文件。不同的文件系统类型有不同的文件存储和访问方式。了解目标系统的文件系统类型可以让攻击者更好地了解目标系统如何存储和访问数据，从而更好地选择攻击方式。\n文件系统类型可以决定目标系统的权限控制方式。不同的文件系统类型有不同的权限控制方式。了解目标系统的文件系统类型可以让攻击者更好地了解目标系统的权限控制方式，从而更好地选择攻击方式。\n文件系统类型可以决定目标系统的可攻击性。一些文件系统类型可能会使系统更容易受到攻击，因为它们可能有更多的漏洞或更脆弱的访问控制。了解目标系统的文件系统类型可以让攻击者更好地了解目标系统的可攻击性，从而更好地选择攻击方式。\n文件系统类型可以影响攻击者选择的攻击向量。不同的文件系统类型可能有不同的漏洞和安全弱点，攻击者可以根据目标系统的文件系统类型来选择特定的攻击向量，以更好地进行攻击。\n\n同时，可以看到新目录的名字叫_iotdev_firmware.bin.extracted，进入后，使用指令ls即可看到该目录下的子目录\n步骤五里，进入squashfs-root目录后还是用ls指令查看子目录。\n\n然后输入readelf -h /sbin/route查看可执行文件的格式信息，显示如下，其中OS/ABI(Operating System/ Application Binary Interface)就是指该文件是在哪个操作系统下运行的以及其对应的开发接口标准，这个开发接口标准可以先不管，只用看对应的操作系统就行，这里可以看到对应的操作系统是UNIX，另一个就是Machine，这一栏就是设备架构，可以看到设备架构是Advanced Micro Devices X86-64\n步骤六中，在第b步中，复制文件到当前目录时，输入cp /usr/bin/qemu-mips-static .，这里要注意.和前面的文件路径之间要隔一个空格，不然系统也会报错cp: missing destination file operand after &#39;/usr/bin/qemu-mips-static.&#39;，在第d步中，输入命令时要注意chroot和.也要隔一个空格。第e步打开新的shell后，提示符变成了/ # ，第f步确认路径时，路径变成了只剩一个/，关于chroot和qemu的理解，可以看一下这两篇，linux chroot命令详解 - 腾讯云开发者社区-腾讯云 (tencent.com)，Linux云计算底层技术之一文读懂 Qemu 模拟器 - 知乎 (zhihu.com)。最后在shell里打开bin和sbin文件夹里的其他程序和可执行二进制代码，我们可以先用cd进入bin或sbin，看看里面都有哪些文件，随便选几个，然后再chroot . ./qemu-mips-static后面接选的文件的路径就能运行了，比如说我选中了sbin文件夹里的iplink，那我就输如chroot . ./qemu-mips-static /sbin/iplink，差不多就是这样，弄完之后记得输入exit退出shell。\n第二部分是一些思考题，通过网上搜索可以理清答案\n\n什么样的IoT设备固件弱点容易受到影响？\n默认凭证：很多IoT设备都会预装一个默认的用户名和密码，攻击者可以利用这些默认凭证轻松地访问设备，从而攻击设备。\n没有安全更新：许多IoT设备的固件更新很少，这意味着设备可能存在已知漏洞，攻击者可以利用这些漏洞进行攻击。\n明文传输：一些IoT设备在与其他设备通信时会使用明文传输，这使得攻击者可以轻松地窃取数据或者篡改数据，从而攻击设备。\n不安全的接口：一些IoT设备的接口可能存在漏洞或者设计不良，攻击者可以利用这些接口进行攻击，例如通过远程代码执行或者拒绝服务攻击。\n缺乏加密：许多IoT设备没有使用加密技术来保护数据的传输和存储，这使得攻击者可以轻松地窃取数据或者篡改数据，从而攻击设备。\n不安全的配置：一些IoT设备可能允许用户配置安全设置，但是这些设置可能不够安全或者被错误地配置，从而给攻击者提供了可利用的漏洞。\n\n\n描述两种IoT固件攻击，并提出防止该类攻击的措施。\n恶意固件攻击：恶意固件攻击是指攻击者通过替换IoT设备的固件来控制设备。攻击者可以利用这种攻击方式来窃取设备的敏感信息、破坏设备的功能或者在设备中安装后门。恶意固件攻击可以通过一些途径实现，例如利用设备漏洞、利用网络攻击和通过物理接触。防止恶意固件攻击的措施包括：\n对IoT设备进行固件加密和签名，确保只有受信任的固件才能被设备接受并运行。\n对IoT设备进行安全启动，确保设备启动时只能运行经过验证的固件。\n对IoT设备进行漏洞扫描和安全评估，及时发现和修复漏洞。\n\n\nDos/DDoS攻击：DoS/DDoS攻击是指攻击者利用大量的请求或者流量来占用IoT设备的带宽或者计算资源，从而使设备变得不可用。攻击者可以利用这种攻击方式来瘫痪设备或者通过设备进行其他攻击。防止DoS/DDoS攻击的措施包括：\n对IoT设备进行安全配置，包括限制网络访问、限制并发连接数和增加安全认证等。\n对IoT设备进行安全监控，及时检测并阻止恶意流量和请求。\n部署防火墙和负载均衡器来保护IoT设备免受DoS/DDoS攻击。\n\n\n固件反向工程攻击：攻击者利用漏洞、工具或者技术来获取设备固件，然后进行逆向工程分析，以发现漏洞或者植入恶意代码。防范措施：\n设备制造商应采用安全固件开发和部署流程，并确保固件的完整性和安全性。\n固件应采用硬件安全模块（HSM）等技术，确保固件不易被修改。\n使用加密算法对固件进行加密，以防止固件泄露。\n\n\n固件漏洞利用攻击：攻击者利用固件中的漏洞，通过远程访问、篡改或者控制设备，从而导致设备的不可用或者信息泄露。防范措施：\n设备制造商应定期更新固件，并提供安全更新以修复漏洞。\n设备制造商应采用安全开发流程，包括漏洞扫描、代码审核和渗透测试，以确保固件的安全性。\n设备管理者应采用强密码，并及时更新密码，以防止攻击者通过破解密码访问设备。\n采用安全通信协议，如HTTPS、SSH等，以确保数据传输的加密和安全。\n\n\n\n\n请用搜索网站查找黑客用于修改固件的工具的名称，例如黑客在二进制固件中加入后门并重新打包为另一个二进制映像文件的工具。该程序是否在Kali Linux操作系统中提供呢？固件篡改过程中会用到FMK工具-firmware-mod-kit，该工具可以利用binwalk等工具从固件中提取出文件系统，将提出的文件系统内容进行篡改后，再重新打包成新的固件包，最后将篡改后的固件包刷新设备中，具体文章为路由器篡改固件添加后门 - FreeBuf网络安全行业门户。该程序在我们自己的kali linux虚拟机上没有事先提供，但是fmk可以下载，并且支持kali linux操作系统。\n\n","tags":["网络安全","物联网安全","linux"]}]